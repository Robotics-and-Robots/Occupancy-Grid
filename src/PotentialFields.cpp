#include "../include/PotentialFields.h"
#include "../include/Constants.h"

/**
 * Updates internal occupancy grid with values form potential
 * fields algorithm. Values are generated considering current
 * state of the grid generated by himm algorithm. 
 */
void PotentialFields::UpdateRoutes(){

	//fill all cells but the bounds
	for(int i = 0; i < OG_WIDTH; i++){
		for(int j = 0; j < OG_HEIGHT; j++){
			if(_grid->Get(i, j) > PF_THRESHOLD)
				_temp_grid->Set(i, j, 1); // wall
			else
				_temp_grid->Set(i, j, 0); //blank
		}
	}
}

/**
 * Ctor.
 * @param grid A pointer to the grid manipulated by himm
 */
PotentialFields::PotentialFields(OccupancyGrid* grid){
	this->_grid = grid;
}

/**
 * Dtor. 
 */
PotentialFields::~PotentialFields(){}

/** Get the next coordinate to walk given current
  * location and a target location */
Pose2D PotentialFields::GetNextPosition(Pose2D pose, Pose2D target){

	OccupancyGrid pf;

	//copy data from the temp_grid
	for(int i = 0; i < OG_WIDTH; i++)
		for(int j = 0; j < OG_HEIGHT; j++)
		       pf.Set(i, j, _temp_grid->Get(i, j));	

	//run potential fields algorithm for k-iterations
	for(int k = 0; k < PF_ITERATIONS; k++){

		//fill all cells but the bounds
		for(int i = 1; i < OG_WIDTH - 1; i++){
			for(int j = 1; j < OG_HEIGHT - 1; j++){

				//wall condition
				if(pf.Get(i, j) == 1)	continue;

				//goal condition
				if(i == target.x && j == target.y) pf.Set(i, j, 0);

				//other cells 
				pf.Set(i, j,
					(pf.Get(i, j + 1) +
					 pf.Get(i, j - 1) + 
					 pf.Get(i + 1, j) +
					 pf.Get(i - 1, j)) / 4);
			}
		}
	}

	//print potential fields result to file
	pf.ToFile("~/Desktop/pf_result.html");
}

void PotentialFields::ToFile(std::string filename){
	_temp_grid->ToFile("~/Desktop/map.html");
}
